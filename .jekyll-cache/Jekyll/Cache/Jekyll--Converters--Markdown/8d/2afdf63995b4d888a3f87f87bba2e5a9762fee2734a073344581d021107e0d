I"¸<p>In case you‚Äôre doing <a href="https://trunkbaseddevelopment.com/">Trunk Based Development</a> (<a href="https://twitter.com/armakunihq/status/976142586388926464">and you should be doing it</a>) you already know or have heard that <a href="https://martinfowler.com/bliki/FeatureToggle.html">Feature Flags</a> are a form of technical debt. In fact, some teams have so many difficulties with this introduced technical debt that they ‚Äúlose trust‚Äù in Trunk Based Development and fallback to Feature Branching. The important thing here to realize is that this is actually a decisive point in the development.</p>

<blockquote>
  <p>Our design communicates to us through resistance</p>
</blockquote>

<p>Some valuable questions worth asking here would be: ‚ÄúIs technical debt inherent problem of Feature Flags or is that pain actually some form of a feedback? Particularly, a feedback about our design and our development process?‚Äù</p>

<p>My guess is that at least three things about feature flags (FF) play a significant feedback role here:</p>

<ul>
  <li>number of occurrences of each feature flag across the codebase</li>
  <li>number of distinct feature flags in the codebase</li>
  <li>feature flag open time</li>
</ul>

<h4 id="number-of-feature-flag-occurrences-as-a-design-feedback">Number of feature flag occurrences as a design feedback</h4>
<p>Usually, when people complain about technical debt when doing Trunk Based Development using feature Flags, they mean the scenario with maintainability difficulties caused by feature flags (i.e. if-elses and switch-cases) being scattered all around the codebase. In this case there are a couple of important questions.</p>

<blockquote>
  <p>What does the fact that, in order to introduce new behavior we have to change the existing code in bunch of places, tell us about our current design?</p>
</blockquote>

<p>What does this pain tell us about adhering to the Open Closed Principle? Perhaps this is a feedback about the fact that it‚Äôs about time to refactor our code so that we could easily slide in new feature hidden behind the feature flag.</p>

<p>Let‚Äôs be clear, our code cannot be prepared for every possible future change, but the most important thing is to recognize the point in time when the feedback surfaces and leverage that useful info to address the root cause. In this case by refactoring and molding the design in order to accommodate new change easily rather than, by inertia, shoveling in bunch of conditional code and increasing the technical debt.</p>

<p>In case of a good design (perhaps SOLID adherent one that is <a href="http://blog.ploeh.dk/2012/01/03/SOLIDisAppend-only/">append only</a>) I‚Äôd say that a given feature flag should be, ideally, present in a single place in code. In case you‚Äôre doing Dependency Injection, that would be a place where you compose your application, meaning composition root. There we‚Äôd have a single conditional, for a given feature flag, for choosing old or new implementation. No if-else proliferation of the feature flags throughout the codebase. No pollution of domain code with feature flags infrastructure.</p>

<h4 id="number-of-distinct-feature-flags-as-a-cycle-time-feedback">Number of distinct feature flags as a cycle time feedback</h4>
<p>Second feedback that we could get use of from feature flags is the number of distinct open feature flags in the codebase. Note: By open, I mean feature flags that are not yet released (meaning deployed but not yet toggled on). Lots of open feature flags add to the overall technical debt in the codebase.</p>

<p>What could the fact that we have so many distinct open feature flags in a given moment mean? What does that tell us about the number of things we‚Äôre trying to tackle at a given moment? Are we trying to do too much at the same time? As per <a href="https://en.wikipedia.org/wiki/Little%27s_law">Little‚Äôs law</a>, limiting work in progress (WIP) helps in <a href="https://www.youtube.com/watch?v=W92wG-HW8gg">decreasing cycle time</a>. Thus, limiting number of features we‚Äôre working on in a given time can be very beneficial for the team in order to delivery feature faster and get faster feedback about the value that it‚Äôs trying to add to the user. At the same time this approach decreases technical debt by not having many feature flags open and lots of conditionality scattered across the codebase.</p>

<h4 id="feature-flag-open-time-as-a-work-size-feedback">Feature flag open time as a work size feedback</h4>
<p>One more factor that contributes to the ‚Äúfeature flags are technical debt‚Äù story are feature flags that are open for a long time. This means that we have conditionality for a long time in the codebase, thus contributing to the overall technical debt. What does this long feature flag open time represent?</p>

<blockquote>
  <p>Long lived branches with Feature Branching are bad, but long lived open Feature Flags with Trunk Based Development are not that better</p>
</blockquote>

<p>Perhaps, feature flag open time can tell us about the size of the work for a given feature? Are we trying to tackle too much? Can we split the feature into multiple vertical slices of functionality that could be delivered faster to the user so that we could get faster feedback? Guess what, additional bonus is that they don‚Äôt get to be in the code base for a long time, thus not contributing to the ‚Äúfeature flags are a technical debt‚Äù story.</p>

<h5 id="summary">Summary:</h5>

<p>Feature flags don‚Äôt have to be technical debt. If they are, then we might at least ask ourselves the question: ‚ÄúIs that pain some kind of feedback that we could leverage to improve our design and development process, rather than solving the wrong problem?‚Äù Or to put it bluntly, if feature flags are technical debt then you‚Äôve got some more important problems to solve.</p>
:ET